<?php 

/**
 * Open Data Repository Data Publisher
 * RRUFF References Plugin
 * (C) 2015 by Nathan Stone (nate.stone@opendatarepository.org)
 * (C) 2015 by Alex Pires (ajpires@email.arizona.edu)
 * Released under the GPLv2
 *
 * The RRUFF References plugin works like the standard references plugin...but also overrides the
 * search for the Journal field, has an autogenerated external ID column, and renames files uploaded
 * to it.
 *
 */

namespace ODR\OpenRepository\GraphBundle\Plugins\RRUFF;

// Entities
use ODR\AdminBundle\Entity\DataFields;
use ODR\AdminBundle\Entity\DataRecordFields;
use ODR\AdminBundle\Entity\File;
// Events
use ODR\AdminBundle\Component\Event\DatafieldModifiedEvent;
use ODR\AdminBundle\Component\Event\DatarecordCreatedEvent;
use ODR\AdminBundle\Component\Event\FilePreEncryptEvent;
use ODR\AdminBundle\Component\Event\MassEditTriggerEvent;
use ODR\AdminBundle\Component\Event\PluginOptionsChangedEvent;
// Exceptions
use ODR\AdminBundle\Exception\ODRBadRequestException;
use ODR\AdminBundle\Exception\ODRException;
// Services
use ODR\AdminBundle\Component\Service\CacheService;
use ODR\AdminBundle\Component\Service\DatabaseInfoService;
use ODR\AdminBundle\Component\Service\DatarecordInfoService;
use ODR\AdminBundle\Component\Service\EntityCreationService;
use ODR\AdminBundle\Component\Service\EntityMetaModifyService;
use ODR\AdminBundle\Component\Service\LockService;
use ODR\AdminBundle\Component\Service\SortService;
use ODR\AdminBundle\Component\Utility\ValidUtility;
use ODR\OpenRepository\SearchBundle\Component\Service\SearchQueryService;
// ODR
use ODR\OpenRepository\GraphBundle\Plugins\Base\FileRenamerPlugin;
use ODR\OpenRepository\GraphBundle\Plugins\DatafieldReloadOverrideInterface;
use ODR\OpenRepository\GraphBundle\Plugins\DatatypePluginInterface;
use ODR\OpenRepository\GraphBundle\Plugins\FileRenamerPluginInterface;
use ODR\OpenRepository\GraphBundle\Plugins\MassEditTriggerEventInterface;
use ODR\OpenRepository\GraphBundle\Plugins\SearchOverrideInterface;
use ODR\OpenRepository\GraphBundle\Plugins\TableResultsOverrideInterface;
// Symfony
use Doctrine\ORM\EntityManager;
use Symfony\Bridge\Monolog\Logger;
use Symfony\Bundle\FrameworkBundle\Templating\EngineInterface;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;
use Symfony\Component\Security\Csrf\CsrfTokenManager;


class RRUFFReferencesPlugin implements DatatypePluginInterface, MassEditTriggerEventInterface, SearchOverrideInterface, FileRenamerPluginInterface, DatafieldReloadOverrideInterface, TableResultsOverrideInterface
{

    /**
     * @var EntityManager
     */
    private $em;

    /**
     * @var CacheService
     */
    private $cache_service;

    /**
     * @var DatabaseInfoService
     */
    private $database_info_service;

    /**
     * @var DatarecordInfoService
     */
    private $datarecord_info_service;

    /**
     * @var EntityCreationService
     */
    private $entity_create_service;

    /**
     * @var EntityMetaModifyService
     */
    private $entity_modify_service;

    /**
     * @var LockService
     */
    private $lock_service;

    /**
     * @var SearchQueryService
     */
    private $search_query_service;

    /**
     * @var SortService
     */
    private $sort_service;

    /**
     * @var EventDispatcherInterface
     */
    private $event_dispatcher;

    // NOTE - $dispatcher is an instance of \Symfony\Component\Event\EventDispatcher in prod mode,
    //  and an instance of \Symfony\Component\Event\Debug\TraceableEventDispatcher in dev mode

    /**
     * @var CsrfTokenManager
     */
    private $token_manager;

    /**
     * @var EngineInterface
     */
    private $templating;

    /**
     * @var Logger
     */
    private $logger;


    /**
     * RRUFF References constructor
     *
     * @param EntityManager $entity_manager
     * @param CacheService $cache_service
     * @param DatabaseInfoService $database_info_service
     * @param DatarecordInfoService $datarecord_info_service
     * @param EntityCreationService $entity_create_service
     * @param EntityMetaModifyService $entity_meta_modify_service
     * @param LockService $lock_service
     * @param SearchQueryService $search_query_service
     * @param SortService $sort_service
     * @param EventDispatcherInterface $event_dispatcher
     * @param CsrfTokenManager $token_manager
     * @param EngineInterface $templating
     * @param Logger $logger
     */
    public function __construct(
        EntityManager $entity_manager,
        CacheService $cache_service,
        DatabaseInfoService $database_info_service,
        DatarecordInfoService $datarecord_info_service,
        EntityCreationService $entity_create_service,
        EntityMetaModifyService $entity_meta_modify_service,
        LockService $lock_service,
        SearchQueryService $search_query_service,
        SortService $sort_service,
        EventDispatcherInterface $event_dispatcher,
        CsrfTokenManager $token_manager,
        EngineInterface $templating,
        Logger $logger
    ) {
        $this->em = $entity_manager;
        $this->cache_service = $cache_service;
        $this->database_info_service = $database_info_service;
        $this->datarecord_info_service = $datarecord_info_service;
        $this->entity_create_service = $entity_create_service;
        $this->entity_modify_service = $entity_meta_modify_service;
        $this->lock_service = $lock_service;
        $this->search_query_service = $search_query_service;
        $this->sort_service = $sort_service;
        $this->event_dispatcher = $event_dispatcher;
        $this->token_manager = $token_manager;
        $this->templating = $templating;
        $this->logger = $logger;
    }


    /**
     * @inheritDoc
     */
    public function canExecutePlugin($render_plugin_instance, $datatype, $rendering_options)
    {
        if ( isset($rendering_options['context']) ) {
            $context = $rendering_options['context'];

            if ($context === 'display' || $context === 'edit'
                || $context === 'fake_edit' || $context === 'mass_edit'
            ) {
                // Needs to be executed in display, edit (for journal selection and previews),
                //  fake_edit (for autogeneration), and mass_edit (for switching to a specific journal)
                return true;
            }

            // Also need a "text" mode
            if ( $context === 'text' || $context === 'html' )
                return true;
        }

        // Otherwise, don't execute the plugin
        return false;
    }


    /**
     * @inheritDoc
     */
    public function execute($datarecords, $datatype, $render_plugin_instance, $theme_array, $rendering_options, $parent_datarecord = array(), $datatype_permissions = array(), $datafield_permissions = array(), $token_list = array())
    {
        try {
            // ----------------------------------------
            // If no rendering context set, then return nothing so ODR's default templating will
            //  do its job
            if ( !isset($rendering_options['context']) )
                return '';


            // ----------------------------------------
            // Need this to determine whether to throw an error or not
            $is_datatype_admin = $rendering_options['is_datatype_admin'];

            // Going to need these...
            $fields = $render_plugin_instance['renderPluginMap'];
            $options = $render_plugin_instance['renderPluginOptionsMap'];

            // The datatype array shouldn't be wrapped with its ID number here...
            $initial_datatype_id = $datatype['id'];

            // The theme array is stacked, so there should be only one entry to find here...
            $initial_theme_id = '';
            foreach ($theme_array as $t_id => $t)
                $initial_theme_id = $t_id;

            // There *should* only be a single datarecord in $datarecords...
            $datarecord = array();
            foreach ($datarecords as $dr_id => $dr)
                $datarecord = $dr;


            // ----------------------------------------
            // Output depends on which context the plugin is being executed from
            $context = $rendering_options['context'];
            $output = '';
            if ( $context === 'display' || $context === 'text' || $context === 'html' ) {

                // Want to locate the values for most of the mapped datafields
                $optional_fields = array(
                    'Reference ID' => 0
                );

                $datafield_mapping = array();
                foreach ($fields as $rpf_name => $rpf_df) {
                    // Need to find the real datafield entry in the primary datatype array
                    $rpf_df_id = $rpf_df['id'];

                    $df = null;
                    if ( isset($datatype['dataFields'][$rpf_df_id]) )
                        $df = $datatype['dataFields'][$rpf_df_id];

                    if ($df == null) {
                        // Optional fields don't have to exist for this plugin to work
                        if ( isset($optional_fields[$rpf_name]) )
                            continue;

                        // If the datafield doesn't exist in the datatype_array, then either the datafield
                        //  is non-public and the user doesn't have permissions to view it (most likely),
                        //  or the plugin somehow isn't configured correctly

                        // The plugin can't continue executing in either case...
                        if ( !$is_datatype_admin )
                            // ...regardless of what actually caused the issue, the plugin shouldn't execute
                            return '';
                        else
                            // ...but if a datatype admin is seeing this, then they probably should fix it
                            throw new \Exception('Unable to locate array entry for the field "'.$rpf_name.'", mapped to df_id '.$rpf_df_id.'...check plugin config.');
                    }
                    else {
                        // The non-optional fields really should all be public...so actually throw an
                        //  error if any of them aren't and the user can do something about it
                        if ( isset($optional_fields[$rpf_name]) )
                            continue;

                        // If the datafield is non-public...
                        $df_public_date = ($df['dataFieldMeta']['publicDate'])->format('Y-m-d H:i:s');
                        if ( $df_public_date == '2200-01-01 00:00:00' ) {
                            if ( !$is_datatype_admin )
                                // ...but the user can't do anything about it, then just refuse to execute
                                return '';
                            else
                                // ...the user can do something about it, so they need to fix it
                                throw new \Exception('The field "'.$rpf_name.'" is not public...all fields except reference_id MUST be public.');
                        }
                    }

                    $typeclass = $df['dataFieldMeta']['fieldType']['typeClass'];

                    // Grab the fieldname specified in the plugin's config file to use as an array key
                    $key = strtolower(str_replace(' ', '_', $rpf_name));

                    // The datafield may have a render plugin that should be executed, but only if
                    //  it's not a file field...
                    if ( !empty($df['renderPluginInstances']) && $typeclass !== 'File' ) {
                        foreach ($df['renderPluginInstances'] as $rpi_id => $rpi) {
                            if ( $rpi['renderPlugin']['render'] !== false ) {
                                // ...if it does, then create an array entry for it
                                $datafield_mapping[$key] = array(
                                    'datafield' => $df,
                                    'render_plugin_instance' => $rpi
                                );
                            }
                        }
                    }

                    // If it does have a render plugin, then don't bother looking in the datarecord array
                    //  for the value
                    if ( isset($datafield_mapping[$key]) )
                        continue;


                    // Otherwise, look for the value in the datarecord array
                    if ( !isset($datarecord['dataRecordFields'][$rpf_df_id]) ) {
                        // As far as the reference plugin is concerned, empty strings are acceptable
                        //  values when datarecordfield entries don't exist
                        $datafield_mapping[$key] = '';
                    }
                    else if ($typeclass === 'File') {
                        $datafield_mapping[$key] = array(
                            'datarecordfield' => $datarecord['dataRecordFields'][$rpf_df_id]
                        );
                    }
                    else {
                        // Don't need to execute a render plugin on this datafield's value...extract it
                        //  directly from the datarecord array
                        // $drf is guaranteed to exist at this point
                        $drf = $datarecord['dataRecordFields'][$rpf_df_id];
                        $value = '';

                        switch ($typeclass) {
                            case 'IntegerValue':
                                $value = $drf['integerValue'][0]['value'];
                                break;
                            case 'DecimalValue':
                                $value = $drf['decimalValue'][0]['original_value'];
                                break;
                            case 'ShortVarchar':
                                $value = $drf['shortVarchar'][0]['value'];
                                break;
                            case 'MediumVarchar':
                                $value = $drf['mediumVarchar'][0]['value'];
                                break;
                            case 'LongVarchar':
                                $value = $drf['longVarchar'][0]['value'];
                                break;
                            case 'LongText':
                                $value = $drf['longText'][0]['value'];
                                break;
                            case 'DateTimeValue':
                                $value = $drf['dateTimeValue'][0]['value']->format('Y-m-d');
                                if ($value == '9999-12-31')
                                    $value = '';
                                $datafield_mapping[$key] = $value;
                                break;

                            default:
                                throw new \Exception('Invalid Fieldtype');
                                break;
                        }

                        $datafield_mapping[$key] = trim($value);
                    }
                }

                // Need to try to ensure urls are valid...
                if ( $datafield_mapping['url'] !== '' ) {
                    // Ensure that DOIs that aren't entirely links still are valid
                    if ( strpos($datafield_mapping['url'], 'doi:') === 0 )
                        $datafield_mapping['url'] = 'https://doi.org/'.trim( substr($datafield_mapping['url'], 4) );

                    // Ensure that the values have an 'https://' prefix
                    if ( strpos($datafield_mapping['url'], 'http') !== 0 )
                        $datafield_mapping['url'] = 'https://'.$datafield_mapping['url'];
                }

                // Going to render the reference differently if it's top-level...
                $is_top_level = $rendering_options['is_top_level'];

                $output = $this->templating->render(
                    'ODROpenRepositoryGraphBundle:RRUFF:RRUFFReferences/rruffreferences_display.html.twig',
                    array(
                        'datarecord' => $datarecord,
                        'mapping' => $datafield_mapping,

                        'is_top_level' => $is_top_level,
                        'original_context' => $rendering_options['context'],
                    )
                );

                // If meant for text output, then replace all whitespace sequences with a single space
                if ( $rendering_options['context'] === 'text' )
                    $output = preg_replace('/(\s+)/', ' ', $output);
            }
            else if ( $context === 'fake_edit') {
                // Retrieve mapping between datafields and render plugin fields
                $autogenerate_df_id = null;
                $plugin_fields = array();
                foreach ($fields as $rpf_name => $rpf_df) {
                    // Need to find the real datafield entry in the primary datatype array
                    $rpf_df_id = $rpf_df['id'];

                    $df = null;
                    if ( isset($datatype['dataFields']) && isset($datatype['dataFields'][$rpf_df_id]) )
                        $df = $datatype['dataFields'][$rpf_df_id];

                    // Autogenerated fields will continue to work even if the user can't see them,
                    //  but probably should still complain about plugin mapping errors to datatype admins
                    if ($df == null && $is_datatype_admin)
                        throw new \Exception('Unable to locate array entry for the field "'.$rpf_name.'", mapped to df_id '.$rpf_df_id);

                    // Need to tweak display parameters for several of the fields...
                    $plugin_fields[$rpf_df_id] = $rpf_df;
                    $plugin_fields[$rpf_df_id]['rpf_name'] = $rpf_name;

                    // Need to generate a special token for the reference_id field
                    if ( $rpf_name === 'Reference ID' )
                        $autogenerate_df_id = $rpf_df_id;
                }

                // Need to provide a special token so the "Reference ID" field won't get ignored
                //  by FakeEdit due to preventing user edits...
                $token_id = 'FakeEdit_'.$datarecord['id'].'_'.$autogenerate_df_id.'_autogenerated';
                $token = $this->token_manager->getToken($token_id)->getValue();
                $special_tokens[$autogenerate_df_id] = $token;


                // Also want to provide a sorted list of the existing journals to the user to reduce
                //  input errors...
                $journal_df_id = 0;
                if ( !isset($fields['Journal']['id']) ) {
                    // If the Journal field doesn't exist, then the plugin can't continue executing
                    if ( !$is_datatype_admin )
                        // ...regardless of what actually caused the issue, the plugin shouldn't execute
                        return '';
                    else
                        // ...but if a datatype admin is seeing this, then they probably should fix it
                        throw new \Exception('Unable to locate array entry for the field "Journal"...check plugin config.');
                }

                $journal_df_id = $fields['Journal']['id'];
                $sort_data = $this->sort_service->sortDatarecordsByDatafield($journal_df_id);

                $journal_list = array();
                foreach ($sort_data as $dr_id => $sort_value)
                    $journal_list[$sort_value] = 1;


                $output = $this->templating->render(
                    'ODROpenRepositoryGraphBundle:RRUFF:RRUFFReferences/rruffreferences_fakeedit_fieldarea.html.twig',
                    array(
                        'datatype_array' => array($initial_datatype_id => $datatype),
                        'datarecord_array' => array($datarecord['id'] => $datarecord),
                        'theme_array' => $theme_array,

                        'target_datatype_id' => $initial_datatype_id,
                        'parent_datarecord' => $parent_datarecord,
                        'target_datarecord_id' => $datarecord['id'],
                        'target_theme_id' => $initial_theme_id,

                        'datatype_permissions' => $datatype_permissions,
                        'datafield_permissions' => $datafield_permissions,

                        'is_top_level' => $rendering_options['is_top_level'],
                        'is_link' => $rendering_options['is_link'],
                        'display_type' => $rendering_options['display_type'],

                        'token_list' => $token_list,
                        'special_tokens' => $special_tokens,

                        'plugin_fields' => $plugin_fields,

                        'journal_df_id' => $journal_df_id,
                        'journal_list' => $journal_list,
                    )
                );
            }
            else if ( $context === 'edit' || $context === 'mass_edit' ) {
                // Want to provide a sorted list of the existing journals to the user to reduce
                //  input errors...
                $journal_df_id = 0;
                if ( !isset($fields['Journal']['id']) ) {
                    // If the Journal field doesn't exist, then the plugin can't continue executing
                    if ( !$is_datatype_admin )
                        // ...regardless of what actually caused the issue, the plugin shouldn't execute
                        return '';
                    else
                        // ...but if a datatype admin is seeing this, then they probably should fix it
                        throw new \Exception('Unable to locate array entry for the field "Journal"...check plugin config.');
                }

                $journal_df_id = $fields['Journal']['id'];
                $sort_data = $this->sort_service->sortDatarecordsByDatafield($journal_df_id);

                $journal_list = array();
                foreach ($sort_data as $dr_id => $sort_value)
                    $journal_list[$sort_value] = 1;

                if ( $context === 'edit' ) {
                    // Most of the fields need slightly modified saving javascript...
                    $reference_field_list = array();
                    foreach ($fields as $rpf_name => $rpf) {
                        switch ($rpf_name) {
                            case 'Authors':
                            case 'Article Title':
                            case 'Journal':
                            case 'Year':
                            case 'Month':
                            case 'Volume':
                            case 'Issue':
                            case 'Book Title':
                            case 'Publisher':
                            case 'Publisher Location':
                            case 'Pages':
                            case 'File':
                            case 'URL':
                                $reference_field_list[ $rpf['id'] ] = $rpf_name;
                                break;
                        }
                    }

                    // Also need a list of which datafields are using the chemistry plugin
                    // TODO - figure out some way to make plugins play nicer with each other?
                    $chemistry_plugin_fields = array();
                    foreach ($datatype['dataFields'] as $df_id => $df) {
                        foreach ($df['renderPluginInstances'] as $rpi_id => $rpi) {
                            if ( $rpi['renderPlugin']['pluginClassName'] === 'odr_plugins.base.chemistry' ) {
                                $subscript_delimiter = $rpi['renderPluginOptionsMap']['subscript_delimiter'];
                                $superscript_delimiter = $rpi['renderPluginOptionsMap']['superscript_delimiter'];

                                $chemistry_plugin_fields[$df_id] = array(
                                    'subscript_delimiter' => $subscript_delimiter,
                                    'superscript_delimiter' => $superscript_delimiter,
                                );
                            }
                        }
                    }

                    // Need to be able to pass this option along if doing edit mode
                    $edit_shows_all_fields = $rendering_options['edit_shows_all_fields'];
                    $edit_behavior = $rendering_options['edit_behavior'];

                    $output = $this->templating->render(
                        'ODROpenRepositoryGraphBundle:RRUFF:RRUFFReferences/rruffreferences_edit_fieldarea.html.twig',
                        array(
                            'datatype_array' => array($initial_datatype_id => $datatype),
                            'datarecord_array' => array($datarecord['id'] => $datarecord),
                            'theme_array' => $theme_array,

                            'target_datatype_id' => $initial_datatype_id,
                            'parent_datarecord' => $parent_datarecord,
                            'target_datarecord_id' => $datarecord['id'],
                            'target_theme_id' => $initial_theme_id,

                            'datatype_permissions' => $datatype_permissions,
                            'datafield_permissions' => $datafield_permissions,
                            'edit_shows_all_fields' => $edit_shows_all_fields,
                            'edit_behavior' => $edit_behavior,

                            'is_top_level' => $rendering_options['is_top_level'],
                            'is_link' => $rendering_options['is_link'],
                            'display_type' => $rendering_options['display_type'],

                            'token_list' => $token_list,

                            'reference_field_list' => $reference_field_list,
                            'chemistry_plugin_fields' => $chemistry_plugin_fields,
                            'journal_list' => $journal_list,
                        )
                    );
                }
                else if ( $context === 'mass_edit' ) {
                    $output = $this->templating->render(
                        'ODROpenRepositoryGraphBundle:RRUFF:RRUFFReferences/rruffreferences_massedit_fieldarea.html.twig',
                        array(
                            'datatype_array' => array($initial_datatype_id => $datatype),
                            'theme_array' => $theme_array,

                            'target_datatype_id' => $initial_datatype_id,
                            'target_theme_id' => $initial_theme_id,

                            'is_datatype_admin' => $is_datatype_admin,
                            'datatype_permissions' => $datatype_permissions,
                            'datafield_permissions' => $datafield_permissions,

                            'is_top_level' => $rendering_options['is_top_level'],

                            'mass_edit_trigger_datafields' => $rendering_options['mass_edit_trigger_datafields'],

                            'journal_df_id' => $journal_df_id,
                            'journal_list' => $journal_list,
                        )
                    );
                }
            }

            return $output;
        }
        catch (\Exception $e) {
            // Just rethrow the exception
            throw $e;
        }
    }


    /**
     * @inheritDoc
     */
    public function canExecuteSearchPlugin($render_plugin_instance, $datatype, $datafield, $rendering_options)
    {
        // Only want to override the Journal field
        if ( isset($render_plugin_instance['renderPluginMap']['Journal']['id']) ) {
            $journal_df_id = $render_plugin_instance['renderPluginMap']['Journal']['id'];
            return array('Journal' => $journal_df_id);
        }

        // If the journal field isn't mapped for some reason, return nothing
        return array();
    }


    /**
     * @inheritDoc
     */
    public function executeSearchPlugin($render_plugin_instance, $datatype, $datafield, $preset_value, $rendering_options)
    {
        // This will only be called on the Journal field...want to provide a dropdown of all journals
        //  currently listed in the field
        $sort_data = $this->sort_service->sortDatarecordsByDatafield( $datafield['id'] );

        $journal_list = array();
        foreach ($sort_data as $dr_id => $sort_value)
            $journal_list[$sort_value] = 1;

        $output = $this->templating->render(
            'ODROpenRepositoryGraphBundle:RRUFF:RRUFFReferences/rruffreferences_search_journal_datafield.html.twig',
            array(
                'datatype' => $datatype,
                'datafield' => $datafield,

                'journal_list' => $journal_list,

                'preset_value' => $preset_value,
            )
        );

        return $output;
    }


    /**
     * @inheritDoc
     */
    public function getSearchOverrideFields($df_list)
    {
        // The array entry for 'Journal' will only exist if the search system needs to run a search
        //  on the field
        if ( isset($df_list['Journal']) )
            return array( 'Journal' => $df_list['Journal'] );
        else
            return array();
    }


    /**
     * @inheritDoc
     */
    public function searchOverriddenField($datafield, $search_term, $render_plugin_fields, $render_plugin_options)
    {
        // The goal is to modify the Journal field so doublequotes around the search term are treated
        //  as matching the entire field, instead of just a ~phrase~ inside the field...which is how
        //  SearchQueryService::parseField() behaves by default
        // e.g.  "\"Inorganic Chemistry\"" should not match "\"Inorganic Chemistry Communications\""

        // ----------------------------------------
        // Have to re-implement SearchService::searchTextOrNumberDatafield() here, so that the call
        //  to SearchQueryService::searchTextOrNumberDatafield() can receive a different parameter
        $allowed_typeclasses = array(
            'LongText'
        );
        $typeclass = $datafield->getFieldType()->getTypeClass();
        if ( !in_array($typeclass, $allowed_typeclasses) )
            throw new ODRBadRequestException('RRUFFReferencesPlugin::searchOverriddenField() called with '.$typeclass.' datafield', 0x49ee1545);


        // ----------------------------------------
        // See if this search result is already cached...
        $cached_searches = $this->cache_service->get('cached_search_df_'.$datafield->getId());
        if ( !$cached_searches )
            $cached_searches = array();

        // Since MYSQL's collation is case-insensitive, the php caching should treat it the same
        $value = $search_term['value'];
        $cache_key = mb_strtolower($value);
        if ( isset($cached_searches[$cache_key]) )
            return $cached_searches[$cache_key];


        // ----------------------------------------
        // Otherwise, going to need to run the search again...

        // The entire reason why searches of this field get overridden is so that doublequotes
        //  match the entire field instead of just a substring
        // e.g. "\"Inorganic Chemistry\"" should not match "\"Inorganic Chemistry Communications\""
        $doublequotes_force_exact_match = true;

        $result = $this->search_query_service->searchTextOrNumberDatafield(
            $datafield->getDataType()->getId(),
            $datafield->getId(),
            $typeclass,
            $value,
            $doublequotes_force_exact_match
        );

        $end_result = array(
            'dt_id' => $datafield->getDataType()->getId(),
            'records' => $result['records'],
            'guard' => $result['guard'],
        );

        // ...then recache the search result
        $cached_searches[$cache_key] = $end_result;
        $this->cache_service->set('cached_search_df_'.$datafield->getId(), $cached_searches);

        // ...then return it
        return $end_result;
    }


    /**
     * Handles when a datarecord is created.
     *
     * @param DatarecordCreatedEvent $event
     */
    public function onDatarecordCreate(DatarecordCreatedEvent $event)
    {
        // Pull some required data from the event
        $user = $event->getUser();
        $datarecord = $event->getDatarecord();
        $datatype = $datarecord->getDataType();

        // Need to locate the "reference_id" field for this render plugin...
        $query = $this->em->createQuery(
           'SELECT df
            FROM ODRAdminBundle:RenderPlugin rp
            JOIN ODRAdminBundle:RenderPluginInstance rpi WITH rpi.renderPlugin = rp
            JOIN ODRAdminBundle:RenderPluginMap rpm WITH rpm.renderPluginInstance = rpi
            JOIN ODRAdminBundle:DataFields df WITH rpm.dataField = df
            JOIN ODRAdminBundle:RenderPluginFields rpf WITH rpm.renderPluginFields = rpf
            WHERE rp.pluginClassName = :plugin_classname AND rpi.dataType = :datatype
            AND rpf.fieldName = :field_name
            AND rp.deletedAt IS NULL AND rpi.deletedAt IS NULL AND rpm.deletedAt IS NULL
            AND df.deletedAt IS NULL'
        )->setParameters(
            array(
                'plugin_classname' => 'odr_plugins.rruff.rruff_references',
                'datatype' => $datatype->getId(),
                'field_name' => 'Reference ID'
            )
        );
        $results = $query->getResult();
        if ( count($results) !== 1 )
            throw new ODRException('Unable to find the "Reference ID" field for the "RRUFF References" RenderPlugin, attached to Datatype '.$datatype->getId());

        // Will only be one result, at this point
        $datafield = $results[0];
        /** @var DataFields $datafield */


        // ----------------------------------------
        // Need to acquire a lock to ensure that there are no duplicate values
        $lockHandler = $this->lock_service->createLock('datatype_'.$datatype->getId().'_autogenerate_id'.'.lock', 15);    // 15 second ttl
        if ( !$lockHandler->acquire() ) {
            // Another process is in the mix...block until it finishes
            $lockHandler->acquire(true);
        }

        // Now that a lock is acquired, need to find the "most recent" value for the field that is
        //  getting incremented...
        $old_value = self::findCurrentValue($datafield->getId());

        // Since the "most recent" mineral id is already an integer, just add 1 to it
        $new_value = $old_value + 1;

        // Create a new storage entity with the new value
        $this->entity_create_service->createStorageEntity($user, $datarecord, $datafield, $new_value, false);    // guaranteed to not need a PostUpdate event
        $this->logger->debug('Setting df '.$datafield->getId().' "Reference ID" of new dr '.$datarecord->getId().' to "'.$new_value.'"...', array(self::class, 'onDatarecordCreate()'));

        // No longer need the lock
        $lockHandler->release();


        // ----------------------------------------
        // Fire off an event notifying that the modification of the datafield is done
        try {
            $event = new DatafieldModifiedEvent($datafield, $user);
            $this->event_dispatcher->dispatch(DatafieldModifiedEvent::NAME, $event);
        }
        catch (\Exception $e) {
            // ...don't want to rethrow the error since it'll interrupt everything after this
            //  event
//            if ( $this->container->getParameter('kernel.environment') === 'dev' )
//                throw $e;
        }

        // ...don't need to mark the datarecord as updated though
    }


    /**
     * For this database, the reference_id needs to be autogenerated.
     *
     * Don't particularly like random render plugins finding random stuff from the database, but
     * there's no other way to satisfy the design requirements.
     *
     * @param int $datafield_id
     *
     * @return int
     *
     * @throws \Doctrine\DBAL\DBALException
     */
    private function findCurrentValue($datafield_id)
    {
        // Going to use native SQL...DQL can't use limit without using querybuilder...
        // NOTE - the query intentionally includes deleted entries, since we never want to reuse
        //  reference_ids even if the associated mineral got deleted for some reason
        $query =
           'SELECT e.value
            FROM odr_integer_value e
            WHERE e.data_field_id = :datafield
            ORDER BY e.value DESC
            LIMIT 0,1';
        $params = array(
            'datafield' => $datafield_id,
        );
        $conn = $this->em->getConnection();
        $results = $conn->executeQuery($query, $params);

        // Should only be one value in the result...
        $current_value = null;
        foreach ($results as $result)
            $current_value = intval( $result['value'] );

        // ...but if there's not for some reason, return zero as the "current".  onDatarecordCreate()
        //  will increment it so that the value one is what will actually get saved.
        // NOTE - this shouldn't happen for the existing references
        if ( is_null($current_value) )
            $current_value = 0;

        return $current_value;
    }


    /**
     * Returns whether the given datafield is using the FileRenamer plugin.
     *
     * @param DataFields $datafield
     *
     * @return bool
     */
    private function isEventRelevant($datafield)
    {
        // Going to use the cached datatype array to locate the correct datafield...
        $datatype = $datafield->getDataType();
        $dt_array = $this->database_info_service->getDatatypeArray($datatype->getGrandparent()->getId(), false);    // don't want links

        $dt = $dt_array[$datatype->getId()];
        if ( !isset($dt['dataFields']) || !isset($dt['dataFields'][$datafield->getId()]) )
            return false;

        if ( !isset($dt['renderPluginInstances']) )
            return false;

        foreach ($dt['renderPluginInstances'] as $rpi_id => $rpi) {
            if ( $rpi['renderPlugin']['pluginClassName'] === 'odr_plugins.rruff.rruff_references' ) {
                // Datatype is using the correct plugin...
                return true;
            }
        }

        // Otherwise, the event needs to be ignored
        return false;
    }


    /**
     * {@inheritDoc}
     *
     * Determines what the files uploaded to the given dataRecordFields entity should actually
     * be named on the server, based on the given plugin config.
     *
     * This is generally similar to {@link FileRenamerPlugin::getNewFilenames()}, but it's somewhat
     * simpler because all the data for the new filename is guaranteed to come from the same record
     * that the file is uploaded to.
     *
     * @param DataRecordFields $original_drf
     * @return array|string Returns an array of changes organized by file/image id, or a single
     *                      string attempting to indicate why the "correct" names can't be determined
     */
    public function getNewFilenames($original_drf)
    {
        if ( is_null($original_drf) )
            throw new ODRBadRequestException('Unable to find new filenames for a null drf', 0x49ee1545);

        $datarecord = $original_drf->getDataRecord();
        $datafield = $original_drf->getDataField();
        $typeclass = $datafield->getFieldType()->getTypeClass();
        if ( $typeclass !== 'File' )
            throw new ODRBadRequestException('Unable to find new filenames for a '.$typeclass.' field', 0x49ee1545);

        // Don't have any config options for this...
//        // Determine the requested configuration info from the plugin's config
//        $config_info = self::getCurrentPluginConfig($df);
//        // If nothing is configured, then don't attempt to rename any files/images
//        if ( empty($config_info) )
//            return array();


        // ----------------------------------------
        // Makes no sense to run all this stuff if the field has no files/images in it
        $entities = $original_drf->getFile();
        $entities = $entities->toArray();
        if ( empty($entities) )
            return array();


        // ----------------------------------------
        // Need the cache entry for the file's datatype...
        $dt_array = $this->database_info_service->getDatatypeArray($datafield->getDataType()->getGrandparent()->getId(), false);  // don't want links
        $dt_array = $dt_array[$datafield->getDataType()->getId()];

        // ...because we need the renderPluginField -> dataField mapping
        $rpf_mapping = array();
        foreach ($dt_array['renderPluginInstances'] as $rpi_num => $rpi) {
            if ( $rpi['renderPlugin']['pluginClassName'] === 'odr_plugins.rruff.rruff_references' ) {
                foreach ($rpi['renderPluginMap'] as $rpf_name => $rpf_data)
                    $rpf_mapping[$rpf_name] = $rpf_data['id'];
            }
        }


        // ----------------------------------------
        // Don't have to find an "ultimate ancestor" or anything...just get the cache entry for
        //  the file's datarecord
        $dr_array = $this->datarecord_info_service->getDatarecordArray($datarecord->getGrandparent()->getId(), false);  // don't want links
        $dr_array = $dr_array[$datarecord->getId()];
        // Don't want to stack this array, because that would force the use of recursion later on

        // Unfortunately, there doesn't seem to be a better method to actually get the values than to
        //  iterate over every single datafield...
        $value_mapping = array();
        foreach ($dr_array['dataRecordFields'] as $df_id => $drf) {
            // The plugin config currently only allowed shortVarchar and longText for the fields of
            //  interest, but might as well get more here in case the config changes later
            if ( isset($drf['shortVarchar']) )
                $value_mapping[$df_id] = $drf['shortVarchar'][0]['value'];
            else if ( isset($drf['mediumVarchar']) )
                $value_mapping[$df_id] = $drf['mediumVarchar'][0]['value'];
            else if ( isset($drf['longVarchar']) )
                $value_mapping[$df_id] = $drf['longVarchar'][0]['value'];
            else if ( isset($drf['longText']) )
                $value_mapping[$df_id] = $drf['longText'][0]['value'];
            else if ( isset($drf['integerValue']) )
                $value_mapping[$df_id] = $drf['integerValue'][0]['value'];
            else if ( isset($drf['decimalValue']) )
                $value_mapping[$df_id] = $drf['decimalValue'][0]['original_value'];
        }


        // ----------------------------------------
        // The files should be named like "<journal, or book_title><volume>_<year>_<pages>.<file_extension>
        $journal = '';

        $pieces = array('journal' => '', 'volume' => '', 'year' => '', 'pages' => '');
        if ( isset($value_mapping[ $rpf_mapping['Journal'] ]) )
            $journal = $value_mapping[ $rpf_mapping['Journal'] ];
        // If the journal is blank, then attempt to use the book title
        if ( $journal === '' && isset($value_mapping[ $rpf_mapping['Book Title'] ]) )
            $journal = $value_mapping[ $rpf_mapping['Book Title'] ];
        // ...if both journal and book title are blank, then decline to rename the file
        if ( $journal === '' )
            return array();

        // Only want at most 50 characters for the journal/book title
        if ( strlen($journal) > 50 )
            $journal = substr($journal, 0, 50);
        // NOTE: this is enough to only truncate ~5% of the values in the database as of 2025/09/03

        $pieces['journal'] = $journal;
        if ( isset($value_mapping[ $rpf_mapping['Volume'] ]) )
            $pieces['volume'] = $value_mapping[ $rpf_mapping['Volume'] ];
        if ( isset($value_mapping[ $rpf_mapping['Year'] ]) )
            $pieces['year'] = $value_mapping[ $rpf_mapping['Year'] ];
        if ( isset($value_mapping[ $rpf_mapping['Pages'] ]) )
            $pieces['pages'] = $value_mapping[ $rpf_mapping['Pages'] ];


        // Cut out invalid characters from the pieces of the new filename
        foreach ($pieces as $name => $val) {
            $val = preg_replace(ValidUtility::FILENAME_ILLEGAL_CHARACTERS_REGEX_A, '', $val);
            $pieces[$name] = str_replace(array(' ',/*'-',*/'_',',','"',"'",'.','(',')'), '', $val);
        }

        $new_filename = $pieces['journal'].$pieces['volume'].'_'.$pieces['year'].'_'.$pieces['pages'];


        // ----------------------------------------
        // Now that we've got part of the filename, we need to update the file uploaded to this drf...
        $new_filenames = array();

        foreach ($entities as $entity) {
            // Should only be one in here
            /** @var File $entity */
            $id = $entity->getId();

            // ...so that the filename for this file/image entity can be determined
            $new_filenames[$id] = array('new_filename' => $new_filename.'.'.$entity->getExt());
            // Never want to change the extension

            // Actually saving the new names is done by whatever called this function
        }

        return $new_filenames;
    }


    /**
     * Attempts to rename a file before it actually gets encrypted by the other parts of ODR.
     *
     * @param FilePreEncryptEvent $event
     *
     * @throws \Exception
     */
    public function onFilePreEncrypt(FilePreEncryptEvent $event)
    {
        // Need these variables defined out here so that the catch block can use them in case
        //  of an error
        $is_event_relevant = false;
        $entity = null;
        $typeclass = null;

        try {
            // Get entities related to the file
            /** @var File $entity */
            $entity = $event->getFile();
            $drf = $entity->getDataRecordFields();
            $datafield = $drf->getDataField();

            $typeclass = $datafield->getFieldType()->getTypeClass();

            // Only care about a file that get uploaded to a field using this plugin...
            $is_event_relevant = self::isEventRelevant($datafield);
            if ( $is_event_relevant ) {
                // This file was uploaded to the correct field, so it now needs to be processed
                $this->logger->debug('Want to rename '.$typeclass.' '.$entity->getId().' "'.$entity->getOriginalFileName().'"...', array(self::class, 'onFilePreEncrypt()', $typeclass.' '.$entity->getId()));

                // ----------------------------------------
                // Since the file hasn't been encrypted yet, it's currently in something of an
                //  odd state...getLocalFileName() doesn't return the entire path to the file, but
                //  just the directory the file/image is in instead
                $local_filepath = $entity->getLocalFileName().'/'.$entity->getOriginalFileName();

                // In order to not wait some unknown amount of time for the file to finish
                //  encrypting, it needs to be renamed before the encryption process...
                $ret = self::getNewFilenames($drf);
                if ( is_array($ret) ) {
                    // ...and after we find the correct name for the newly uploaded file...
                    if ( !isset($ret[$entity->getId()]) )
                        throw new ODRException('onFilePreEncrypt() unable to find new filename for '.$typeclass.' '.$entity->getId(), 0x49ee1545);
                    $data = $ret[$entity->getId()];
                    $new_filename = $data['new_filename'];

                    if ( strlen($new_filename) <= 255 ) {
                        $this->logger->debug('...renaming '.$typeclass.' '.$entity->getId().' to "'.$new_filename.'"...', array(self::class, 'onFilePreEncrypt()', $typeclass.' '.$entity->getId()));

                        // ...save the new filename in the database...
                        $meta_entry = $entity->getFileMeta();
                        $meta_entry->setOriginalFileName($new_filename);
                        $this->em->persist($meta_entry);

                        // ...and move the file on the server so its location matches the database
                        rename($local_filepath, $entity->getLocalFileName().'/'.$new_filename);

                        // In theory, the encryption process should continue on as if the user
                        //  uploaded the file with the "correct" name in the first place

                        // Now that the file/image is named correctly, flush the change
                        $this->em->flush();
                    }
                    else {
                        $this->logger->debug('-- (ERROR) unable to save new filename "'.$new_filename.'" for '.$typeclass.' '.$entity->getId().' because it exceeds 255 characters', array(self::class, 'onFilePreEncrypt()', $typeclass.' '.$entity->getId()));
                    }
                }
                else {
                    // ...if getNewFilenames() returns null, then there's some unrecoverable problem
                    //  that prevents the file/image from being renamed
                    $this->logger->debug('-- (ERROR) unable to rename '.$typeclass.' '.$entity->getId().'...', array(self::class, 'onFilePreEncrypt()', $typeclass.' '.$entity->getId()));

                    // Regardless of the reason why there's a problem, this plugin can't fix it
                    // As such, nothing should be done
                    throw new \Exception($ret);
                }
            }
        }
        catch (\Exception $e) {
            // Can't really display the error to the user yet, but can log it...
            $this->logger->debug('-- (ERROR) '.$e->getMessage(), array(self::class, 'onFilePreEncrypt()', $typeclass.' '.$entity->getId()));

            // DO NOT want to rethrow the error here...if this subscriber "exits with error", then
            //  any additional subscribers won't run either
        }
        finally {
            // Would prefer if these happened regardless of success/failure...
            if ( $is_event_relevant )
                $this->logger->debug('finished rename attempt for '.$typeclass.' '.$entity->getId(), array(self::class, 'onFilePreEncrypt()', $typeclass.' '.$entity->getId()));

            // Don't need to clear any caches here, since the file encryption should handle it
        }
    }


    /**
     * Does the work of renaming files as part of a MassEdit event
     *
     * @param MassEditTriggerEvent $event
     *
     * @throws \Exception
     */
    public function onMassEditTrigger(MassEditTriggerEvent $event)
    {
        // Need these variables defined out here so that the catch block can use them in case
        //  of an error
        $is_event_relevant = false;
        $typeclass = null;

        try {
            // Get entities related to the event
            $drf = $event->getDataRecordFields();
            $datafield = $drf->getDataField();
            $datarecord = $drf->getDataRecord();
            $user = $event->getUser();

            // Only care about a file that get changed in a field using this plugin...
            $is_event_relevant = self::isEventRelevant($datafield);
            if ( $is_event_relevant ) {
                // Load all files/images uploaded to this field
                $typeclass = $datafield->getFieldType()->getTypeClass();

                $query = $this->em->createQuery(
                   'SELECT f
                    FROM ODRAdminBundle:File f
                    WHERE f.dataRecordFields = :drf
                    AND f.deletedAt IS NULL'
                )->setParameters( array('drf' => $drf->getId()) );
                $tmp = $query->getResult();

                // There could be nothing uploaded to the field, or there could be multiple files/images
                /** @var File[] $tmp */
                $entities = array();
                foreach ($tmp as $num => $entity)
                    $entities[ $entity->getId() ] = $entity;
                /** @var File[] $entities */

                // This file was uploaded to the correct field, so it now needs to be processed
                $this->logger->debug('Want to rename the '.$typeclass.'s in datafield '.$datafield->getId().' datarecord '.$datarecord->getId().'...', array(self::class, 'onMassEditTrigger()', 'drf '.$drf->getId()));


                // ----------------------------------------
                // Like the FilePreEncrypt Event, need to figure out the relevant information to be
                //  able to rename the files...
                $ret = self::getNewFilenames($drf);
                if ( is_array($ret) ) {
                    foreach ($ret as $entity_id => $data) {
                        $new_filename = $data['new_filename'];
                        if ( strlen($new_filename) <= 255 ) {
                            // ...so for each file/image uploaded to the datafield...
                            /** @var File $entity */
                            $entity = $entities[$entity_id];
                            $this->logger->debug('...renaming '.$typeclass.' '.$entity->getId().' to "'.$new_filename.'"...', array(self::class, 'onMassEditTrigger()', $typeclass.' '.$entity->getId()));

                            // ...save the new filename in the database...
                            $props = array('original_filename' => $new_filename);
                            $this->entity_modify_service->updateFileMeta($user, $entity, $props, true);
                        }
                        else {
                            $this->logger->debug('-- (ERROR) unable to save new filename "'.$new_filename.'" for '.$typeclass.' '.$entity_id.' because it exceeds 255 characters', array(self::class, 'onMassEditTrigger()', $typeclass.' '.$entity_id));
                        }
                    }

                    // Now that the files are named correctly, flush the changes
                    $this->em->flush();
                }
                else {
                    // ...if getNewFilenames() returns null, then there's some unrecoverable problem
                    //  that prevents the file from being renamed
                    $this->logger->debug('-- (ERROR) unable to rename the '.$typeclass.'s...', array(self::class, 'onMassEditTrigger()', 'drf '.$drf->getId()));

                    // Regardless of the reason why there's a problem, this plugin can't fix it
                    // As such, nothing should be done
                    throw new \Exception($ret);
                }
            }
        }
        catch (\Exception $e) {
            // Can't really display the error to the user yet, but can log it...
            $this->logger->debug('-- (ERROR) '.$e->getMessage(), array(self::class, 'onMassEditTrigger()', 'drf '.$drf->getId()));

            // DO NOT want to rethrow the error here...if this subscriber "exits with error", then
            //  any additional subscribers won't run either
        }
        finally {
            // Would prefer if these happened regardless of success/failure...
            if ( $is_event_relevant )
                $this->logger->debug('finished rename attempt for the '.$typeclass.'s in datafield '.$datafield->getId().' datarecord '.$datarecord->getId(), array(self::class, 'onMassEditTrigger()', 'drf '.$drf->getId()));

            // Don't need to clear caches here, since the mass update process will always do it
        }
    }


    /**
     * @inheritDoc
     */
    public function getMassEditOverrideFields($render_plugin_instance)
    {
        if ( !isset($render_plugin_instance['renderPluginMap']['File']['id']) )
            throw new ODRException('Invalid plugin config');

        // Since this is a datatype plugin, there's going to be multiple fields in here...only want
        //  to display this option for the File field
        return array(
            $render_plugin_instance['renderPluginMap']['File']['id']
        );
    }


    /**
     * @inheritDoc
     */
    public function getMassEditTriggerFields($render_plugin_instance)
    {
        if ( !isset($render_plugin_instance['renderPluginMap']['File']['id']) )
            throw new ODRException('Invalid plugin config');

        // This File field in this plugin does not care whether the user changed the public status
        //  of the file/image field
        $trigger_fields = array();
        $trigger_fields[ $render_plugin_instance['renderPluginMap']['File']['id'] ] = true;

        return $trigger_fields;
    }

    /**
     * @inheritDoc
     */
    public function getOverrideParameters($rendering_context, $render_plugin_instance, $datafield, $datarecord, $theme, $user, $is_datatype_admin)
    {
        // Only override when called from the 'edit' context...the 'display' context might be a
        //  possibility in the future, but this plugin doesn't need to override there
        if ( $rendering_context !== 'edit' )
            return array();

        // Sanity checks
        if ( $render_plugin_instance->getRenderPlugin()->getPluginClassName() !== 'odr_plugins.rruff.rruff_references' )
            return array();
        $datatype = $datafield->getDataType();
        if ( $datatype->getId() !== $datarecord->getDataType()->getId() )
            return array();
        if ( $render_plugin_instance->getDataType()->getId() !== $datatype->getId() )
            return array();


        // ----------------------------------------
        // Need to ensure this only triggers on the File field
        $dt_array = $this->database_info_service->getDatatypeArray($datatype->getGrandparent()->getId(), false);    // don't need links
        $dt = $dt_array[$datafield->getDataType()->getId()];

        $plugin_fields = array();
        foreach ($dt['renderPluginInstances'] as $rpi_id => $rpi) {
            if ( $rpi['renderPlugin']['pluginClassName'] === 'odr_plugins.rruff.rruff_references' ) {
                foreach ($rpi['renderPluginMap'] as $rpf_name => $rpf_data)
                    $plugin_fields[ $rpf_data['id'] ] = $rpf_name;
            }
        }

        // Attempt to locate the name of the field being reloaded
        $rpf_name = '';
        if ( isset($plugin_fields[$datafield->getId()]) )
            $rpf_name = $plugin_fields[$datafield->getId()];
        if ( $rpf_name === '' )
            return array();

        if ( $rpf_name === 'File' ) {
            // Only want to override the File field
            return array(
                'token_list' => array(),    // so ODRRenderService generates CSRF tokens
                'template_name' => 'ODROpenRepositoryGraphBundle:RRUFF:RRUFFReferences/rruffreferences_edit_datafield.html.twig',
            );
        }

        // Otherwise, don't want to override the default reloading for this field
        return array();
    }


    /**
     * @inheritDoc
     */
    public function getTableResultsOverrideValues($render_plugin_instance, $datarecord, $datafield = null)
    {
        // Don't do anything if fields aren't mapped
        $values = array();
        if ( !isset($render_plugin_instance['renderPluginMap']) )
            return array();

        $substitute_article_title = false;
        if ( isset($render_plugin_instance['renderPluginOptionsMap']['substitute_article_title'])
            && $render_plugin_instance['renderPluginOptionsMap']['substitute_article_title'] === 'yes'
        ) {
            $substitute_article_title = true;
        }
        $substitute_journal = false;
        if ( isset($render_plugin_instance['renderPluginOptionsMap']['substitute_journal'])
            && $render_plugin_instance['renderPluginOptionsMap']['substitute_journal'] === 'yes'
        ) {
            $substitute_journal = true;
        }

        // Since this is a datatype plugin, need to dig through the renderPluginInstance array
        $relevant_rpf_names = array('Article Title', 'Book Title', 'Journal', 'Publisher');

        $df_mapping = array();
        $value_mapping = array();
        foreach ($relevant_rpf_names as $rpf_name) {
            $df_id = $render_plugin_instance['renderPluginMap'][$rpf_name]['id'];
            $df_mapping[$rpf_name] = $df_id;

            if ( isset($datarecord['dataRecordFields'][$df_id]) ) {
                $drf = $datarecord['dataRecordFields'][$df_id];

                // Brute-force typeclass since there's only two possibilities
                if ( isset($drf['longText'][0]['value']) )
                    $value_mapping[$df_id] = $drf['longText'][0]['value'];
                else if ( isset($drf['longVarchar'][0]['value']) )
                    $value_mapping[$df_id] = $drf['longVarchar'][0]['value'];
            }
        }


        // Want to put always italics around the Book Title
        $book_title_df_id = $df_mapping['Book Title'];
        if ( isset($value_mapping[$book_title_df_id]) && $value_mapping[$book_title_df_id] !== '' )
            $values[$book_title_df_id] = '<i>'.$value_mapping[$book_title_df_id].'</i>';

        // Only substitute a missing article title if configured to do so...
        if ( $substitute_article_title ) {
            $article_title_df_id = $df_mapping['Article Title'];
            if ( !isset($value_mapping[$article_title_df_id]) || $value_mapping[$article_title_df_id] === '' ) {
                if ( isset($values[$book_title_df_id]) ) {
                    // Replace the missing article title with the book title
                    $values[$article_title_df_id] = $values[$book_title_df_id];
                }
            }
        }

        // Only substitute a missing journal if configured to do so...
        if ( $substitute_journal ) {
            $journal_df_id = $df_mapping['Journal'];
            $publisher_df_id = $df_mapping['Publisher'];
            if ( !isset($value_mapping[$journal_df_id]) || $value_mapping[$journal_df_id] === '' ) {
                if ( isset($value_mapping[$publisher_df_id]) ) {
                    // Replace the missing article title with the book title
                    $values[$journal_df_id] = $value_mapping[$publisher_df_id];
                }
            }
        }


        // Return the value the table should display
        return $values;
    }


    /**
     * Called when a user changes RenderPluginOptions or RenderPluginMaps entries for this plugin.
     *
     * @param PluginOptionsChangedEvent $event
     */
    public function onPluginOptionsChanged(PluginOptionsChangedEvent $event)
    {
        foreach ($event->getChangedOptions() as $rpo_name) {
            if ( $rpo_name === 'substitute_article_title' || $rpo_name === 'substitute_journal' ) {
                // If either of these options got changed, then need to wipe the table entries for
                //  all records of this datatype
                $datatype_id = $event->getRenderPluginInstance()->getDataType()->getId();

                $query =
                   'SELECT dr.grandparent_id AS gdr_id
                    FROM odr_data_record dr
                    WHERE dr.data_type_id = '.$datatype_id.' AND dr.deletedAt IS NULL';
                $conn = $this->em->getConnection();
                $results = $conn->executeQuery($query);

                foreach ($results as $result) {
                    $gdr_id = $result['gdr_id'];
                    $this->cache_service->delete('cached_table_data_'.$gdr_id);
                }
            }
        }
    }
}
